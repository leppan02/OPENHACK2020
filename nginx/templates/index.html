<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <link href="nouislider.min.css" rel="stylesheet">
</head>
<style>

#main-page {
    margin-left: 3em;
    margin-right: 3em;

    display: flex;
    flex-direction: row;
}

#col-left {
    width: 70%;
    padding: 2em;
    box-sizing: border-box;
    margin-right: 1em;
}

#col-right {
    margin-left: 1em;
    margin-top: 5em;
}

#world-map {
    margin-top: 5em;
    width: 100%;
    height: 70vh;
}

#slider {
    width: 100%;
}

.color-hint {
    display: flex;
    flex-direction: row;
    align-items: center;
}

.color-square {
    width: 1em;
    height: 1em;
    border-radius: 5px;
    display: inline-block;
    margin-right: 1ex;
}

</style>

<body>

    <script src="nouislider.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.3/d3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/topojson/1.6.9/topojson.min.js"></script>
    <script src="https://datamaps.github.io/scripts/0.5.8/datamaps.world.hires.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/2.3.10/seedrandom.min.js">
    </script>
    <div id="main-page">
        <div id="col-left">
            <div id="slider"></div>

            <div id="world-map">
            </div>
        </div>
        <div id="col-right">
            <div id="color-hints">
            </div>

            <div id="conflicts">

            </div>
        </div>
    </div>

    <script>
        var map;
        var trades = []
        var mapping = {}
        var reverseMapping = {}
        // var countryFilter = {}
        var fetchedCountry = {}
        var lastCountry = ""
        var country_conflicts = [];

        var color_hints = {}; // {color: key}

        var filter_weapons = new Set(["Aircraft"]);

        window.onload = async function () {
            map = new Datamap({
                element: document.getElementById("world-map"),
                projection: "mercator",
                done: function (datamap) {
                    datamap.svg.selectAll('.datamaps-subunit').on('click', async function (geography) {
                        console.log(geography)
                        // countryFilter[geography.id] ^= 1
                        await fetchAndProcessCountry(geography.id)
                        await updateArcs(geography.id)
                    });
                },
                arcConfig: {
                    strokeColor: '#DD1C7760',
                    strokeWidth: 1,
                    arcSharpness: 1,
                    animationSpeed: 1500, // Milliseconds
                    popupOnHover: true, // True to show the popup while hovering
                    popupTemplate: function (geography, data) { // This function should just return a string
                        // Case with latitude and longitude
                        if ((data.origin && data.destination) && data.origin.latitude && data.origin.longitude && data.destination.latitude && data.destination.longitude) {
                            return '<div class="hoverinfo"><strong>Arc</strong><br>Origin: ' + JSON.stringify(data.origin) + '<br>Destination: ' + JSON.stringify(data.destination) + '</div>';
                        }
                        // Case with only country name
                        else if (data.origin && data.destination) {
                            return '<div class="hoverinfo"><strong>Arc</strong><br>' +
                                data.origin + ' -> ' + data.destination + '<br>' +
                                data.w_name + " x " + data.w_amount + "</div>";
                        }
                        // Missing information
                        else {
                            return '';
                        }
                    }
                },
                fills: {
                    defaultFill: "#152624",
                    hasConflict: "#888888"
                },
            });

            var slider = document.getElementById('slider');

            noUiSlider.create(slider, {
                start: [2019, 2020],
                connect: true,
                range: {
                    'min': 2000,
                    'max': 2020
                },
                step: 1,
                pips: {
                    mode: 'steps',
                    density: 1,
                    // format: wNumb({
                    //     decimals: 2,
                    //     prefix: 'â‚¬'
                    // })
                }
            });

            slider.noUiSlider.on("update", function () {
                updateArcs(lastCountry);
                updateConflicts();
            })

            geometries = map.worldTopo.objects.world.geometries
            for (i = 0; i < geometries.length; i++) {
                mapping[geometries[i].properties.name] = geometries[i].id
                reverseMapping[geometries[i].id] = geometries[i].properties.name
            }
            mapping["Russia"] = "RUS"
            reverseMapping["RUS"] = "Russia"

            mapping["Iran"] = "IRN"
            reverseMapping["IRN"] = "Iran"

            mapping["Laos"] = "LAO"
            reverseMapping["LAO"] = "Laos"

            mapping["Venezuela"] = "VEN"
            reverseMapping["VEN"] = "Venezuela"

            for (countrymapping in mapping) {
                // countryFilter[mapping[countrymapping]] = 0
                fetchedCountry[mapping[countrymapping]] = false
            }

            await fetchAndProcessCountry("SWE")
            await fetchAndProcessConflicts();

            await updateArcs()
            updateConflicts();
        }

        async function fetchAndProcessConflicts() {
            response_raw = await fetch(document.location.origin + '/api/query_conflict');
            response = await response_raw.json();

            country_conflicts = {};
            for (var i = 0; i < response.length; i++) {
                let conflict = response[i];
                if (!(conflict.country in country_conflicts)) {
                    country_conflicts[conflict.country] = [];
                }

                country_conflicts[conflict.country].push({
                    "picture_url" : conflict["picture_url"],
                    "source" : conflict["source"],
                    "info" : conflict["info"],
                });
            }
        }

        function updateConflicts() {
            for (country in mapping) {
                var fillKey = "defaultFill";
                if (country in country_conflicts) {
                    let conflict = country_conflicts[i];

                    fillKey = "hasConflict";
                }

                map.updateChoropleth({
                    [mapping[country]]: { fillKey: fillKey },
                });
            }
        }

        async function fetchAndProcessCountry(countryCode) {
            if (fetchedCountry[countryCode]) return
            var url = new URL(document.location.origin + '/api/query_trade')

            url.search = new URLSearchParams({ "country_from": reverseMapping[countryCode] }).toString();

            let response = await fetch(url);
            let rawTrades = await response.json()

            url = new URL(document.location.origin + '/api/query_trade')

            url.search = new URLSearchParams({ "country_to": reverseMapping[countryCode] }).toString();

            response = await fetch(url);
            rawTrades.concat(response.json())

            for (var i = 0; i < rawTrades.length; i++) {
                if (!(rawTrades[i].country_to in mapping)) {
                    console.log(rawTrades[i].country_to + " not in mapping")
                    continue
                }
                if (!(rawTrades[i].country_from in mapping)) {
                    console.log(rawTrades[i].country_from + " not in mapping")
                    continue
                }

                trades.push({ ...rawTrades[i], country_to: mapping[rawTrades[i].country_to], country_from: mapping[rawTrades[i].country_from] })
            }
            fetchedCountry[countryCode] = true
        }

        function generate_color(previous_colors) {
            var best_color = null;
            var best_dist = 1000000000000;
            for (var i = 0; i < 1000; i++) {
                let new_color = [0 | (Math.random() * 255), 0 | (Math.random() * 255), 0 | (Math.random() * 255)];

                var dist = 0;
                for (var j = 0; j < previous_colors.length; j++) {
                    dist += 1 / (50 + Math.abs(new_color[0] - previous_colors[j][0]));
                    dist += 1 / (50 + Math.abs(new_color[1] - previous_colors[j][1]));
                    dist += 1 / (50 + Math.abs(new_color[2] - previous_colors[j][2]));
                }

                if (dist < best_dist) {
                    best_color = new_color;
                    best_dist = dist;
                }
            }
            return best_color;
        }

        async function updateArcs(countryCode) {
            let arcs = []
            let minyear = Math.round(slider.noUiSlider.get()[0])
            let maxyear = Math.round(slider.noUiSlider.get()[1])
            console.log(minyear)
            console.log(maxyear)

            color_hints = {};
            var colors = [[0, 0, 0], [0, 0, 0], [255, 255, 255], [255, 255, 255]];
            var colors_added = [];

            for (trade in trades) {
                // console.log(trades[trade].country_from === countryCode || trades[trade].country_to === countryCode)
                // console.log(trade.trade_start >= minyear)
                // console.log(trade.trade_start <= maxyear)
                // console.log(trade)
                if ((trades[trade].country_from === countryCode || trades[trade].country_to === countryCode) && trades[trade].trade_start >= minyear && trades[trade].trade_start <= maxyear) {

                    Math.seedrandom(trades[trade])
                    var sharp = 1 - Math.random() * 2;

                    var color;
                    if (trades[trade].weapon_name in color_hints) {
                        color = color_hints[trades[trade].weapon_name].color;
                    } else {
                        color = generate_color(colors);
                        colors.push(color);
                        color = "rgba(" + color[0] + ", " + color[1] + ", " + color[2] + ", 0.5)";
                        color_hints[trades[trade].weapon_name] = {"color": color};
                    }

                    if (!filter_weapons.has(trades[trade].weapon_name) && filter_weapons.size > 0) {
                        continue;
                    }
                    arcs.push({
                        origin: trades[trade].country_from,
                        destination: trades[trade].country_to,
                        arcSharpness: sharp,
                        strokeColor: color,
                        strokeWidth: 2 + Math.log(trades[trade].amount),
                        w_name: trades[trade].weapon_name,
                        w_amount: trades[trade].amount,
                    })
                }

            }
            map.arc(arcs)
            lastCountry = countryCode

            render_sidebar();
        }

        function render_sidebar() {
            let elem = document.getElementById("color-hints");

            elem.innerHTML = "";

            for (weapon_name in color_hints) {
                var square = document.createElement("div");
                square.className += "color-square";
                square.style = "background: " + color_hints[weapon_name].color + ";";

                var color_hint = document.createElement("div");
                color_hint.className += "color-hint";
                color_hint.appendChild(square);

                var desc = document.createTextNode("- " + weapon_name);
                if (filter_weapons.has(weapon_name)) {
                    var desc_ = document.createElement("b");
                    desc_.appendChild(desc);
                    desc = desc_;
                }

                let name = weapon_name; // Capture
                color_hint.addEventListener("click", () => {
                    console.log("hej " + name);
                    if (filter_weapons.has(name)) {
                        filter_weapons.delete(name);
                    } else {
                        filter_weapons.add(name);
                    }
                    render_sidebar();
                    updateArcs(lastCountry);
                });

                color_hint.appendChild(desc);

                elem.appendChild(color_hint);
            }
        }

    </script>
</body>
</html>
